import { NextRequest, NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';

export const dynamic = 'force-dynamic';

const ENV_FILE_PATH = path.join(process.cwd(), '.env.local');

// Helper to parse .env file
function parseEnvFile(content: string): Record<string, string> {
  const env: Record<string, string> = {};
  const lines = content.split('\n');

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;

    const match = trimmed.match(/^([^=]+)=(.*)$/);
    if (match) {
      const key = match[1].trim();
      let value = match[2].trim();

      // Remove quotes if present
      if ((value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }

      env[key] = value;
    }
  }

  return env;
}

// Helper to serialize env object to .env format
function serializeEnvFile(env: Record<string, string>): string {
  const lines: string[] = [];

  // Add header comment
  lines.push('# OS Athena Environment Variables');
  lines.push('# Generated by Settings UI');
  lines.push('');

  // Group by provider
  const groups = {
    'AI Providers': [
      'CLAUDE_API_KEY',
      'OPENAI_API_KEY',
      'GROQ_API_KEY',
      'GEMINI_API_KEY',
      'OPENROUTER_API_KEY',
      'FIREWORKS_API_KEY',
      'MISTRAL_API_KEY',
      'COHERE_API_KEY',
      'PERPLEXITY_API_KEY',
      'OPENCODE_API_KEY',
      'OLLAMA_API_KEY',
    ],
    'Deployment Providers': [
      'GITHUB_TOKEN',
      'VERCEL_TOKEN',
      'RENDER_API_KEY',
    ],
    'Other': [],
  };

  // Add grouped keys
  for (const [groupName, keys] of Object.entries(groups)) {
    const groupKeys = keys.filter(key => env[key]);
    if (groupKeys.length > 0 || groupName === 'Other') {
      lines.push(`# ${groupName}`);

      if (groupName === 'Other') {
        // Add any keys not in predefined groups
        const allKnownKeys = new Set([...groups['AI Providers'], ...groups['Deployment Providers']]);
        const otherKeys = Object.keys(env).filter(key => !allKnownKeys.has(key));
        otherKeys.forEach(key => {
          lines.push(`${key}="${env[key]}"`);
        });
      } else {
        groupKeys.forEach(key => {
          lines.push(`${key}="${env[key]}"`);
        });
      }

      lines.push('');
    }
  }

  return lines.join('\n');
}

// GET - Read current environment variables
export async function GET() {
  try {
    let envContent = '';

    try {
      envContent = await fs.readFile(ENV_FILE_PATH, 'utf-8');
    } catch (error) {
      // File doesn't exist yet, return empty object
      return NextResponse.json({ env: {} });
    }

    const env = parseEnvFile(envContent);

    // Only return non-empty values (mask actual values for security)
    const maskedEnv: Record<string, boolean> = {};
    for (const [key, value] of Object.entries(env)) {
      maskedEnv[key] = value.length > 0;
    }

    return NextResponse.json({ env: maskedEnv });
  } catch (error) {
    console.error('Error reading .env.local:', error);
    return NextResponse.json(
      { error: 'Failed to read environment variables' },
      { status: 500 }
    );
  }
}

// POST - Update or add environment variable
export async function POST(request: NextRequest) {
  try {
    const { key, value } = await request.json();

    if (!key || typeof key !== 'string') {
      return NextResponse.json(
        { error: 'Invalid key' },
        { status: 400 }
      );
    }

    if (typeof value !== 'string') {
      return NextResponse.json(
        { error: 'Invalid value' },
        { status: 400 }
      );
    }

    // Read current env
    let env: Record<string, string> = {};
    try {
      const envContent = await fs.readFile(ENV_FILE_PATH, 'utf-8');
      env = parseEnvFile(envContent);
    } catch (error) {
      // File doesn't exist, will create new one
    }

    // Update or add the key
    env[key] = value;

    // Write back to file
    const newContent = serializeEnvFile(env);
    await fs.writeFile(ENV_FILE_PATH, newContent, 'utf-8');

    return NextResponse.json({ success: true, message: 'Environment variable saved' });
  } catch (error) {
    console.error('Error updating .env.local:', error);
    return NextResponse.json(
      { error: 'Failed to update environment variable' },
      { status: 500 }
    );
  }
}

// DELETE - Remove environment variable
export async function DELETE(request: NextRequest) {
  try {
    const { key } = await request.json();

    if (!key || typeof key !== 'string') {
      return NextResponse.json(
        { error: 'Invalid key' },
        { status: 400 }
      );
    }

    // Read current env
    let env: Record<string, string> = {};
    try {
      const envContent = await fs.readFile(ENV_FILE_PATH, 'utf-8');
      env = parseEnvFile(envContent);
    } catch (error) {
      return NextResponse.json(
        { error: 'Environment file not found' },
        { status: 404 }
      );
    }

    // Remove the key
    delete env[key];

    // Write back to file
    const newContent = serializeEnvFile(env);
    await fs.writeFile(ENV_FILE_PATH, newContent, 'utf-8');

    return NextResponse.json({ success: true, message: 'Environment variable deleted' });
  } catch (error) {
    console.error('Error deleting from .env.local:', error);
    return NextResponse.json(
      { error: 'Failed to delete environment variable' },
      { status: 500 }
    );
  }
}
